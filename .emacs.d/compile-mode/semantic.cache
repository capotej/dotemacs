;; Object semantic.cache
;; SEMANTICDB Tags save file
(semanticdb-project-database "semantic.cache"
  :file "semantic.cache"
  :tables (list 
   (semanticdb-table "compile-mode.el"
    :file "compile-mode.el"
    :pointmax 101475
    :major-mode 'emacs-lisp-mode
    :tokens '(("compile" include nil nil nil [12639 12657]) ("byte-compile" include nil nil nil [12696 12730]) ("backquote" include nil nil nil [12751 12771]) ("cl" include nil nil nil [12772 12785]) ("load-library" code nil [12786 12810]) ("pp" include nil nil nil [12833 12846]) ("condition-case" code nil [12893 12954]) ("if" code nil [12957 13241]) ("condition-case" code nil [13310 13369]) ("if" code nil [13372 13673]) ("defgroup" code nil [13693 13911]) ("defgroup" code nil [13912 14028]) ("defgroup" code nil [14029 14117]) ("defgroup" code nil [14118 14232]) ("mode-compile-modes-alist" variable nil (quote ((c-mode cc-compile kill-compilation) (java-mode java-compile kill-compilation) (c++-mode c++-compile kill-compilation) (ada-mode ada-compile kill-compilation) (fortran-mode f77-compile kill-compilation) (dired-mode dired-compile kill-compilation) (emacs-lisp-mode elisp-compile keyboard-quit) (lisp-interaction-mode elisp-compile keyboard-quit) (makefile-mode makefile-compile kill-compilation) (sh-mode sh-compile kill-compilation) (csh-mode csh-compile kill-compilation) (zsh-mode zsh-compile kill-compilation) (perl-mode perl-compile kill-compilation) (cperl-mode perl-compile kill-compilation) (tcl-mode tcl-compile kill-compilation) (python-mode python-compile kill-compilation) (ruby-mode ruby-compile kill-compilation) (fundamental-mode guess-compile nil) (text-mode guess-compile nil) (indented-text-mode guess-compile nil) (compilation-mode default-compile kill-compilation))) nil "Assoc list of compile/kill functions for some known modes.

Each element look like (MODE . (COMPILE-FUNCTION KILL-FUNCTION))
 `mode-compile' will call COMPILE-FUNCTION and `mode-compile-kill'
 KILL-FUNCTION if current major-mode is MODE.

If you want to add or modify a COMPILE-FUNCTION and it's associated
KILL-FUNCTION for MODE and don't want to hack `mode-compile' you could
do the following (it exists however a more subtle method for
modifying, this is left as an exercice for the reader :-):
 (defun my-mode-compile() ...)
 (defun my-mode-compile-kill() ...)
 (setq mode-compile-modes-alist
       (append '((my-mode . (my-mode-compile my-mode-compile-kill)))
               mode-compile-modes-alist))" nil [14316 17756]) ("mode-compile-filename-regexp-alist" variable nil (quote ((mode-compile-makefile-regexp . makefile-mode) ("\\.sh$" . sh-mode) ("\\.csh$" . csh-mode) ("\\.zsh$" . zsh-mode))) nil "Assoc list of major-modes for some filenames regexp.

Each element look like (REGEXP . MODE) This variable is really similar
to `auto-mode-alist' in the fact that it associate a MODE to a REGEXP
matching a filename. The only differences is that you are not obliged
to have the specified MODE available to use it (`guess-compile' use
it), the MODE is only a pointer to an assoq in
`mode-compile-modes-alist' to get the COMPILE-FUNCTION and the
KILL-FUNCTION. The REGEXP could be a form wich evaluate to a string.

To add a new filename regexp do the following:
 (setq mode-compile-filename-regexp-alist
       (append '((my-filename-regexp . some-mode-mode-compile-know)
               mode-compile-modes-alist))" nil [17758 19522]) ("mode-compile-shell-alist" variable nil (quote (("sh" . sh-mode) ("csh" . csh-mode) ("zsh" . zsh-mode) ("perl" . perl-mode) ("tcl" . tcl-mode) ("python" . python-mode) ("ruby" . ruby-mode))) nil "Assoc list of compile function for some known shells.

Each element look like (SHELL . MODE) This variable look like
`auto-mode-alist' in the fact that it associate a MODE to a name; A
SHELL name here. The main difference is that you are not obliged to
have the specified MODE available to use it (`guess-compile' use it),
the MODE is only a pointer to an assoq in `mode-compile-modes-alist'
to get the COMPILE-FUNCTION and the KILL-FUNCTION.

To add a new shell do the following:
 (setq mode-compile-filename-shell-alist
       (append '((my-shell-name . some-mode-mode-compile-know)
               mode-compile-modes-alist))" nil [19524 20803]) ("mode-compile-make-program" variable nil "make" ((user-visible . t)) "*The `make' program used to process makefiles.

If you have GNU make installed with name \"gmake\" use it." nil [20820 21013]) ("mode-compile-makefile-regexp" variable nil "\\(^[Mm]akefile\\|.*\\.[mM][aA]?[kK][eE]?\\.?.*$\\)" nil "Regexp matching 'could be' makefiles filenames." nil [21015 21201]) ("mode-compile-makefile-backups-regexp" variable nil "\\(\\(~\\|\\.[bB][aA][cC]?[kK]\\)$\\)\\|\\(\\(^\\|/\\)[.,][^/]+$\\)" nil "Regexp to find if a Makefile is a backup or not" nil [21203 21413]) ("mode-compile-ignore-makefile-backups" variable nil t ((user-visible . t)) "*Tell mode compile to ignore makefiles backup files when selecting the Makefile to use." nil [21430 21611]) ("mode-compile-default-make-options" variable nil "-k" nil "Default options to give to `make'." nil [21628 21714]) ("mode-compile-make-options" variable nil (eval mode-compile-default-make-options) ((user-visible . t)) "*Options to give to `make'.
This could be any form evaluating to a string.

Some people asked me a way to modify the make options everytime a
compilation command is launched, do that:
 (defun my-mode-compile-ask-make-options()
   \"*Hook called by mode-compile, asking for make options.\"
   (interactive)
   (read-string \"Make options: \"
                mode-compile-default-make-options))
 (setq mode-compile-make-options
           'my-mode-compile-ask-make-options)" nil [21730 22393]) ("mode-compile-prefered-default-makerule" variable nil (quote none) ((user-visible . t)) "*Default makerule you would like to see in minibuffer as a default choice
when selecting the make rule to build.

Possible values are:
'none    -- let mode-compile deciding for you.
'all     -- try hard to show you the \"all\" rule.
'default -- try hard to show you the \"default\" rule.
'file    -- try to show you the name of the file which will be
            result of compilation.
The 'none action is taken as default is something fail." nil [22410 23285]) ("mode-compile-ignore-makerule-regexp" variable nil nil ((user-visible . t)) "*Makefile rules which must be ignored when building completion list.

For example if you want to remove all `files rules' set
it to: \"\\\\.\\\\([aoc]\\\\|s[ao][.0-9]*\\\\)\". " nil [23302 23721]) ("mode-compile-save-all-p" variable nil nil ((user-visible . t)) "*Non-nil means save ALL the modified buffers without asking
before launching compilation command." nil [23738 23918]) ("mode-compile-always-save-buffer-p" variable nil nil ((user-visible . t)) "*Non-nil means save the current buffer without asking
before launching compilation command." nil [23935 24119]) ("mode-compile-never-edit-command-p" variable nil nil ((user-visible . t)) "*Non-nil means never ask to user to edit the compile command." nil [24136 24290]) ("defgroup" code nil [24334 24445]) ("mode-compile-other-frame-p" variable nil nil ((user-visible . t)) "*Non-nil means compile in another frame.

A new Emacs FRAME is created and the compilation command is executed
in this other frame.  To specify the frame parameters see also
variable `mode-compile-frame-parameters-alist'." nil [24462 24775]) ("mode-compile-other-frame-name" variable nil "COMPILATION" nil "Name of mode-compile's other frame.

This name could be used in your .Xdefault or .Xresources file as:
Emacs.MODE-COMPILE-OTHER-FRAME-NAME.resource_to_be_set: ..." nil [24777 25043]) ("mode-compile-default-frame-parameters" variable nil (list (cons (quote name) mode-compile-other-frame-name) (cons (quote width) 85) (cons (quote height) 30)) ((const . t)) "Default parameters for mode-compile's other frame." nil [25045 25267]) ("mode-compile-frame-parameters-alist" variable nil (purecopy mode-compile-default-frame-parameters) nil "Parameters for the new Compilation Screen created
if variable `mode-compile-other-frame-p' is non nil..

See also variable `mode-compile-default-frame-parameters' and
`mode-compile-other-frame-name'.

For informations about Screen/Frame parameters see:
- Info, Nodes: Lispref::Screen::Screen Parameters
- GNU Emacs Lisp Reference Manual, chapter 26 p375: Frames." nil [25269 25731]) ("mode-compile-before-compile-hook" variable nil nil nil "Hook to be run before compile command is executed
when `mode-compile' is invoked." nil [25765 25935]) ("mode-compile-after-compile-hook" variable nil nil nil "Hook to be run after compile command is executed
when `mode-compile' is invoked." nil [25952 26120]) ("mode-compile-before-kill-hook" variable nil nil nil "Hook to be run before killing compile command is executed
when `mode-compile-kill' is invoked." nil [26137 26317]) ("mode-compile-after-kill-hook" variable nil nil nil "Hook to be run after killing compile command is executed
when `mode-compile-kill' is invoked." nil [26334 26512]) ("mode-compile-exe-file-ext" variable nil (cond ((memq system-type (quote (ms-dos emx windows-95 windows-98 windows-nt))) ".exe") (t "")) ((user-visible . t)) "*Extension of executable files (with dot included)" nil [26545 26731]) ("mode-compile-dir-separator-char" variable nil (cond ((memq system-type (quote (ms-dos emx windows-95 windows-98 windows-nt))) "\\") (t "/")) ((user-visible . t)) "*Separator char between directories" nil [26733 26964]) ("mode-compile-choosen-compiler" variable nil nil ((user-visible . t)) "*Global variable containing the name of the compiler
which will be used for compiling without makefile.

 Could be used in combination with
 (cc|c++|ada|f77)-default-compiler-options
to automaticaly choose the compiler specific options.

example:
 (defun my-compiler-get-options()
   (cond
    ((string= mode-compile-choosen-compiler \"gcc\")
      \"-Wall -pedantic-errors\")
    ((string= mode-compile-choosen-compiler \"cc\")
      \"cc options whatever they are...\")
    (t
     (message \"Don't know this compiler: %s\" mode-compile-choosen-compiler)
     (read-string
      (format \"Options for %s compiler: \" mode-compile-choosen-compiler)))))

  (setq cc-default-compiler-options 'my-compiler-get-options)" nil [27013 27776]) ("mode-compile-expert-p" variable nil nil ((user-visible . t)) "*Non nil means `mode-compile' will not speaks too much.

See also variable variable mode-compile-reading-time." nil [27815 28006]) ("mode-compile-reading-time" variable nil 1 ((user-visible . t)) "*Seconds to wait in verbose mode after printing a message.

In verbose mode mode-compile print too much messages that it is
allmost impossible to read them. Just setting this delay leave you the
time to read all the messages. If you don't want any delay set it to
`0'.

See also function sit-for." nil [28023 28402]) ("defgroup" code nil [28440 28528]) ("mode-compile-remote-hosts-alist" variable nil (quote nil) nil "Alist of favourites hosts names and the username
to use to log on (HOSTNAME . USERNAME).

If USERNAME is a function it will be called with HOSTNAME as argument
and should return an USERNAME string (for example you could use
something like efs-get-user - not tested -), if it is nil the function
user-login-name will be used." nil [28530 29227]) ("mode-compile-remote-execute-command" variable nil "rsh" nil "The shell command used to run a command remotely.
\"rsh\" is the only choice I know but I'm far to know everything...

 This variable is set automaticaly with the value of
remote-shell-program or efs-remote-shell-file-name at load time." nil [29229 29561]) ("eval-when" code nil [29562 30069]) ("mode-compile-remote-execute-set-host-arg" variable nil "" nil "Argument To set the remote host name to the
mode-compile-remote-execute-command,

None is required for \"rsh\"." nil [30071 30287]) ("mode-compile-remote-execute-set-command-arg" variable nil "" nil "Argument to set the command to be run remotely to the
mode-compile-remote-execute-command.

None is required for \"rsh\"." nil [30289 30518]) ("mode-compile-remote-execute-set-username-arg" variable nil "-l" nil "Argument to set the username under which we will log on
on the remote host, to give to mode-compile-remote-execute-command." nil [30520 30754]) ("mode-compile-remote-execute-misc-args" variable nil "" nil "Misc additionnals arguments to give to the
mode-compile-remote-execute-command." nil [30756 30937]) ("defgroup" code nil [30977 31067]) ("cc-compilers-list" variable nil (quote ("gcc" "c89" "acc" "cc")) nil "List of user's favourites C compilers in order of preferencies." nil [31069 31264]) ("cc-companion-file-regexp" variable nil "\\(_[Pp]\\)?\\.[pP]?h" nil "Regexp to find associated .c file from a .h." nil [31266 31411]) ("cc-default-compiler" variable nil "cc" ((user-visible . t)) "*Default C compiler to use when everything else fails.

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"C compiler: \"))
 (setq cc-compilers-list '()
       cc-default-compiler 'my-choose-compiler)" nil [31413 31844]) ("cc-compiler-varenv" variable nil "CC" nil "Varenv indicating the C compiler to use." nil [31846 31962]) ("cc-cflags-varenv" variable nil "CFLAGS" nil "Varenv indicating the C compiler flags to use." nil [31964 32088]) ("cc-source-ext-list" variable nil (quote ("c")) nil "Extensions for C compileable source files." nil [32090 32221]) ("cc-headers-ext-list" variable nil (quote ("h")) nil "Extensions for C headers source files." nil [32223 32351]) ("cc-default-compiler-options" variable nil "-g" ((user-visible . t)) "*Default options to give to the C compiler.

This could be any form evaluating to a string.
See `mode-compile-choosen-compiler' variable." nil [32353 32646]) ("cc-source-file-ext-regexp" variable nil "\\.c" nil "Regexp to find, from it's name, if a C file is compileable." nil [32648 32792]) ("cc-build-output-args" variable nil t nil "Build output-args for c-mode." nil [32794 32899]) ("cc-object-file-ext" variable nil "o" nil "Extension of objects file (result of compilation)
in c mode." nil [32901 33036]) ("defgroup" code nil [33079 33163]) ("java-compilers-list" variable nil (quote ("javac")) nil "List of user's favourites java compilers in order of preferencies." nil [33165 33356]) ("java-companion-file-regexp" variable nil "" nil "Regexp to find associated compileable Java companion file.

This is useless in Java because there do not exists uncompileable files." nil [33358 33575]) ("java-default-compiler" variable nil "javac" ((user-visible . t)) "*Default C compiler to use when everything else fails.

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"Java compiler: \"))
 (setq java-default-compiler 'my-choose-compiler)." nil [33577 33993]) ("java-compiler-varenv" variable nil "JAVAC" nil "Varenv indicating the C compiler to use." nil [33995 34119]) ("java-cflags-varenv" variable nil "JAVAC_FLAGS" nil "Varenv indicating the C compiler flags to use." nil [34121 34255]) ("java-source-ext-list" variable nil (quote ("java")) nil "Extensions for Java compileable source files." nil [34257 34399]) ("java-headers-ext-list" variable nil (quote ("java")) nil "Extensions for Java source files." nil [34401 34532]) ("java-default-compiler-options" variable nil "-O" ((user-visible . t)) "*Default options to give to the Java compiler.

This could be any form evaluating to a string.  See
`mode-compile-choosen-compiler' variable." nil [34534 34836]) ("java-source-file-ext-regexp" variable nil "\\.java" nil "Regexp to find, from it's name, if a Java file is compileable." nil [34838 34993]) ("java-build-output-args" variable nil nil nil "Dont build output-args for Java-mode." nil [34995 35115]) ("java-object-file-ext" variable nil "class" nil "Extension of objects file (result of compilation)
in java mode." nil [35117 35264]) ("defgroup" code nil [35306 35387]) ("c++-compilers-list" variable nil (quote ("g++" "gcc" "CC")) nil "List of user's favourites C++ compilers in order of preferencies." nil [35389 35585]) ("c++-companion-file-regexp" variable nil "\\(_[Pp]\\)?\\.\\([pP]?[Hh][Hh]?\\|[Hh]\\+\\+?\\)" nil "Regexp to find associated compileable C++ companion file
from a header file." nil [35587 35795]) ("c++-default-compiler" variable nil "CC" ((user-visible . t)) "*Default C++ compiler to use when everything else fails..

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"C++ compiler: \"))
 (setq c++-default-compiler 'my-choose-compiler)" nil [35797 36208]) ("c++-compiler-varenv" variable nil "CXX" nil "Varenv indicating the C++ compiler to use." nil [36210 36332]) ("c++-cflags-varenv" variable nil "CXXFLAGS" nil "Varenv indicating the C++ compiler flags to use." nil [36334 36465]) ("c++-source-ext-list" variable nil (quote ("cc" "C" "CC" "cpp" "cxx" "c++" "c+")) nil "Extensions for C++ compileable source files." nil [36467 36636]) ("c++-headers-ext-list" variable nil (quote ("H" "hh" "HH" "h++" "h+" "h" "hpp" "hxx")) nil "Extensions for C++ headers source files." nil [36638 36808]) ("c++-default-compiler-options" variable nil "-g" ((user-visible . t)) "*Default options to give to the C++ compiler.
This could be any form evaluating to a string.  See
`mode-compile-choosen-compiler' variable." nil [36810 37108]) ("c++-source-file-ext-regexp" variable nil "\\.\\(cc\\|CC?\\|c\\+\\+?\\|cpp\\|cxx\\)" nil "Regexp to find, from it's name, if a C++ file is compileable." nil [37110 37295]) ("c++-build-output-args" variable nil t nil "Build output-args for c++-mode." nil [37297 37407]) ("c++-object-file-ext" variable nil "o" nil "Extension of objects file (result of compilation)
in c++ mode." nil [37409 37549]) ("defgroup" code nil [37591 37672]) ("ada-compilers-list" variable nil (quote ("gcc" "gnat" "ada")) nil "List of user's favourites Ada compilers in order of preferencies." nil [37674 37874]) ("ada-companion-file-regexp" variable nil "" nil "Regexp to find associated compileable Ada companion file from a spec file.

This is useless in Ada because there do not exists uncompileable files." nil [37876 38106]) ("ada-default-compiler" variable nil "ada" ((user-visible . t)) "*Default Ada compiler to use when everything else fails.

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"Ada compiler: \"))
 (setq ada-default-compiler 'my-choose-compiler)" nil [38108 38519]) ("ada-compiler-varenv" variable nil "ADA" nil "Varenv indicating the Ada compiler to use." nil [38521 38643]) ("ada-aflags-varenv" variable nil "AFLAGS" nil "Varenv indicating the Ada compiler flags to use." nil [38645 38774]) ("ada-source-ext-list" variable nil (quote ("ads" "adb" "ada" "a")) nil "Extensions for Ada compileable source files." nil [38776 38930]) ("ada-headers-ext-list" variable nil (quote ("ads" "ada" "a")) nil "Extensions for Ada spec source files." nil [38932 39074]) ("ada-default-compiler-options" variable nil "-g" ((user-visible . t)) "*Default options to give to the Ada compiler.

This could be any form evaluating to a string.  See
`mode-compile-choosen-compiler' variable." nil [39076 39375]) ("ada-source-file-ext-regexp" variable nil "\\.\\(ad[abs]\\|a\\)" nil "Regexp to find, from it's name, if an Ada file is compileable.

This is useless in Ada because there do not exists uncompileable files." nil [39377 39616]) ("ada-build-output-args" variable nil t nil "Build output-args for ada-mode." nil [39618 39728]) ("ada-object-file-ext" variable nil "o" nil "Extension of objects file (result of compilation)
in ada mode." nil [39730 39870]) ("defgroup" code nil [39916 40005]) ("f77-compilers-list" variable nil (quote ("f77" "fc")) nil "List of user's favourite Fortran compilers in order of preferencies." nil [40007 40202]) ("f77-companion-file-regexp" variable nil "\\(_[Pp]\\)?\\.[pP]?inc" nil "Regexp to find associated .f file from a .inc." nil [40204 40360]) ("f77-default-compiler" variable nil "f77" ((user-visible . t)) "*Default fortran compiler to use when everything else fails..

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"Fortran compiler: \"))
 (setq f77-default-compiler 'my-choose-compiler)" nil [40362 40786]) ("f77-compiler-varenv" variable nil "F77" nil "Varenv indicating the fortran compiler to use." nil [40788 40918]) ("f77-cflags-varenv" variable nil "FCOPTS" nil "Varenv indicating the fortran compiler flags to use." nil [40920 41057]) ("f77-source-ext-list" variable nil (quote ("f" "F" "for" "For")) nil "Extensions for fortran compileable source files." nil [41059 41219]) ("f77-headers-ext-list" variable nil (quote ("inc" "h")) nil "Extensions for fortran include files." nil [41221 41360]) ("f77-default-compiler-options" variable nil "-w66 -a" ((user-visible . t)) "*Default options to give to the fortran compiler.

This could be any form evaluating to a string.  See
`mode-compile-choosen-compiler' variable." nil [41362 41674]) ("f77-source-file-ext-regexp" variable nil "\\.\\([Ff]\\|for\\)" nil "Regexp to find, from it's name, if a fortran file is compileable." nil [41676 41848]) ("f77-build-output-args" variable nil t nil "Build output-args for f77-mode." nil [41850 41964]) ("f77-object-file-ext" variable nil "o" nil "Extension of objects file (result of compilation)
in Fortran mode." nil [41966 42114]) ("defgroup" code nil [42155 42259]) ("sh-command" variable nil "sh" nil "Command to run sh scripts" nil [42261 42355]) ("sh-dbg-flags" variable nil "-fvx" ((user-visible . t)) "*Flags to give to sh for debugging a Bourne Shell script.

The -f flag must always be present." nil [42357 42524]) ("sh-compilation-error-regexp-alist" variable nil nil nil "Alist that specifies how to match errors in sh output.

See variable compilation-error-regexp-alist for more details." nil [42526 42784]) ("defgroup" code nil [42825 42918]) ("csh-command" variable nil "csh" nil "Command to run csh scripts" nil [42920 43018]) ("csh-dbg-flags" variable nil "-fVX" ((user-visible . t)) "*Flags to give to csh for debugging a C Shell script.

The -f flag must always be present." nil [43020 43185]) ("csh-compilation-error-regexp-alist" variable nil nil nil "Alist that specifies how to match errors in csh output.

See variable compilation-error-regexp-alist for more details." nil [43187 43442]) ("defgroup" code nil [43483 43584]) ("zsh-command" variable nil "zsh" nil "Command to run zsh scripts" nil [43586 43684]) ("zsh-dbg-flags" variable nil "-nCvx" ((user-visible . t)) "*Flags to give to zsh for debugging a Z Shell script." nil [43686 43815]) ("zsh-compilation-error-regexp-alist" variable nil nil nil "Alist that specifies how to match errors in csh output.

See variable compilation-error-regexp-alist for more details." nil [43817 44072]) ("defgroup" code nil [44119 44202]) ("tcl-command" variable nil "wish" nil "Command to run tcl scripts" nil [44204 44303]) ("tcl-dbg-flags" variable nil "" ((user-visible . t)) "*Flags to give to tcl -- none." nil [44305 44406]) ("tcl-compilation-error-regexp-alist" variable nil (quote (("file \"\\([^ ]+\\)\" line \\([0-9]+\\)[)]" 1 2))) nil "Alist that specifies how to match errors in tcl output.

See variable compilation-error-regexp-alist for more details." nil [44408 44694]) ("defgroup" code nil [44743 44832]) ("python-command" variable nil "python" nil "Command to run python scripts" nil [44834 44944]) ("python-dbg-flags" variable nil "" ((user-visible . t)) "*Flags to give to python -- none." nil [44946 45056]) ("python-compilation-error-regexp-alist" variable nil (quote (("File \"\\([^ ]+\\)\", line \\([0-9]+\\).*" 1 2))) nil "Alist that specifies how to match errors in python output.

See variable compilation-error-regexp-alist for more details." nil [45058 45357]) ("defgroup" code nil [45399 45484]) ("perl-command" variable nil "perl" nil "Command to run perl." nil [45486 45581]) ("perl-dbg-flags" variable nil "-w" ((user-visible . t)) "*Flags to give to perl for debugging a Perl script." nil [45583 45709]) ("perl-compilation-error-regexp-alist" variable nil (quote (("in file \\([^ ]+\\) at line \\([0-9]+\\).*" 1 2) ("at \\([^ ]+\\) line \\([0-9]+\\)," 1 2) ("at \\([^ ]+\\) line \\([0-9]+\\)." 1 2))) nil "Alist that specifies how to match errors in perl output.

See variable compilation-error-regexp-alist for more details." nil [45711 46351]) ("defgroup" code nil [46393 46478]) ("ruby-command" variable nil "ruby" nil "Command to run ruby" nil [46480 46577]) ("ruby-dbg-flags" variable nil "-w" nil "Flags to give ruby for catching warnings" nil [46579 46697]) ("ruby-compilation-error-regexp-alist" variable nil (quote (("test[a-zA-Z0-9_]*([A-Z][a-zA-Z0-9_]*) \\[\\(.*\\):\\([0-9]+\\)\\]:" 1 2) ("\\(.*?\\)\\([0-9A-Za-z_./:-]+\\.rb\\):\\([0-9]+\\)" 2 3))) nil "Alist that specifies how to match errors in ruby output.

See variable compilation-error-regexp-alist for more details." nil [46699 47061]) ("emacs-lisp-byte-compile-dir-interactive-p" variable nil t ((user-visible . t)) "*Non-nil means when byte-compiling a directory ask for each file
needing to be recompiled or not." nil [47120 47322]) ("define-obsolete-variable-alias" code nil [47323 47447]) ("emacs-lisp-sources-regexp" variable nil (cond ((boundp (quote emacs-lisp-file-regexp)) emacs-lisp-file-regexp) (t "\\.el$")) nil "Regexp to find emacs lisp sources files." nil [47449 47669]) ("emacs-lisp-bytecomp-ext" variable nil "c" nil "Extension added to byte-compiled emacs sources files." nil [47671 47812]) ("mode-compile-version" variable nil "2.28" ((const . t)) "Current version of mode-compile package.

mode-compile.el,v 2.28 2003/04/01 13:52:47 boubaker Exp
Please send bugs-fixes/contributions/comments to boubaker@cena.fr" nil [47860 48066]) ("mode-compile-help-address" variable nil "heddy.Boubaker@cena.fr" ((const . t)) "E-Mail address of mode-compile maintainer." nil [48068 48176]) ("or" code nil [48417 48676]) ("mc--comp-lst" variable nil nil nil nil nil [48740 48774]) ("mc--def-comp" variable nil nil nil nil nil [48815 48849]) ("mc--compfile-regexp" variable nil nil nil nil nil [48857 48891]) ("mc--comp-varenv" variable nil nil nil nil nil [48899 48933]) ("mc--comp-options" variable nil nil nil nil nil [48941 48975]) ("mc--cflags-varenv" variable nil nil nil nil nil [48983 49017]) ("mc--source-ext-lst" variable nil nil nil nil nil [49025 49059]) ("mc--head-ext-lst" variable nil nil nil nil nil [49067 49101]) ("mc--source-ext-regexp" variable nil nil nil nil nil [49109 49143]) ("mc--build-op-args" variable nil nil nil nil nil [49151 49185]) ("mc--outfile-ext" variable nil nil nil nil nil [49193 49227]) ("mc--efs-path-list" variable nil nil nil nil nil [49252 49288]) ("mc--remote-host" variable nil nil nil nil nil [49289 49325]) ("mc--remote-host-history" variable nil nil nil nil nil [49326 49362]) ("mc--remote-username" variable nil nil nil nil nil [49363 49399]) ("mc--remote-command" variable nil nil nil nil nil [49400 49436]) ("mc--remote-pathname" variable nil nil nil nil nil [49437 49473]) ("mc--other-frame" variable nil nil nil nil nil [49499 49527]) ("mc--ws" variable nil (or (and (fboundp (quote console-type)) (console-type)) (and (fboundp (quote device-type)) (device-type)) window-system) nil nil nil [49528 49699]) ("mc--compile-command" variable nil nil nil nil nil [49701 49733]) ("make-variable-buffer-local" code nil [49948 49997]) ("mc--kill-compile" variable nil nil nil nil nil [49999 50028]) ("make-variable-buffer-local" code nil [50091 50137]) ("mc--selected-makefile" variable nil nil nil nil nil [50139 50173]) ("mc--selected-makefile-history" variable nil nil nil nil nil [50174 50216]) ("make-variable-buffer-local" code nil [50430 50481]) ("mc--selected-makerule" variable nil nil nil nil nil [50483 50517]) ("mc--selected-makerule-history" variable nil nil nil nil nil [50518 50560]) ("make-variable-buffer-local" code nil [50753 50804]) ("mc--find-C-main-regexp" variable nil "^[ 	]*\\(int\\|void\\)?[ 	
]*main[ 	
]*(+" ((const . t)) nil nil [50806 50892]) ("mc--makefile-rules-regexp" variable nil "^
*\\([^.$ 	#
][^$ 	#
:]*\\)[ 	]*:" ((const . t)) nil nil [50948 51029]) ("mc--makefile-rules" variable nil nil nil nil nil [51158 51189]) ("make-variable-buffer-local" code nil [51235 51283]) ("mc--mkfl-buffer-tick" variable nil nil nil nil nil [51285 51318]) ("make-variable-buffer-local" code nil [51387 51437]) ("mc--shell-args" variable nil nil nil nil nil [51439 51466]) ("make-variable-buffer-local" code nil [51668 51712]) ("mc--lucid-emacs-p" variable nil (or (string-match "Lucid" emacs-version) (string-match "XEmacs" emacs-version)) ((const . t)) nil nil [51770 51911]) ("if" code nil [51955 52047]) ("mc--compile" function nil ("compile-command") nil (if (null mc--remote-command) (mc--compile-sav compile-command) (let ((thisdir (expand-file-name (or default-directory "~")))) (mc--compile-sav (concat mc--remote-command "'( cd " thisdir " ; " compile-command " )'")))) nil [52049 52620]) ("mc--msg" function nil ("msg" "&rest" "args") nil (cond ((not mode-compile-expert-p) (apply (quote message) (concat "mode-compile: " msg) args) (sit-for mode-compile-reading-time))) nil [52622 52896]) ("cond" code nil [52898 54065]) ("mc--funcall" function nil ("command" "&rest" "params") nil (cond ((and (eq mc--ws (quote x)) mode-compile-other-frame-p) (mc--msg "Switching to another frame to compile...") (let ((buffer (current-buffer)) (win-attr (or mode-compile-frame-parameters-alist mode-compile-default-frame-parameters)) (frame (cond ((fboundp (quote mc--frame-live-p)) (if (mc--frame-live-p mc--other-frame) mc--other-frame nil)) (t (mc--msg "Don't know how to check frame existence.") nil)))) (cond ((fboundp (quote mc--make-frame)) (mc--select-frame (or frame (setq mc--other-frame (mc--make-frame win-attr)))) (mc--make-frame-visible mc--other-frame) (mc--raise-frame mc--other-frame) (switch-to-buffer buffer)) (t (mc--msg "Don't know how to create a new frame.")))))) nil [54067 55703]) ("mc--byte-compile-buffer" function nil nil nil (if (fboundp (quote byte-compile-buffer)) (byte-compile-buffer) (let ((tmp-file (concat (or (getenv "TMPDIR") (concat mode-compile-dir-separator-char "tmp")) mode-compile-dir-separator-char (make-temp-name "mc--")))) (save-restriction (widen) (write-region (point-min) (point-max) tmp-file) (condition-case err (byte-compile-file tmp-file) (error (mc--msg "Failing to byte-compile %s, #error %s" (buffer-name) err))) (delete-file tmp-file) (let ((elc-file (concat tmp-file emacs-lisp-bytecomp-ext))) (if (file-writable-p elc-file) (condition-case err (delete-file elc-file) (error (mc--msg "Failing to delete %s, #error %s" elc-file err))))) (message nil)))) nil [55705 56794]) ("fset" code nil [56818 57167]) ("fset" code nil [57169 57490]) ("mc--read-string" function nil ("prompt" "&optional" "initial-contents") nil (if mc--lucid-emacs-p (read-string prompt initial-contents (quote compile-history)) (read-string prompt initial-contents)) nil [57492 57788]) ("mc--eval" function nil ("sym" "&optional" "arg") nil (\` (cond ((and (symbolp (\, sym)) (fboundp (\, sym))) (funcall (\, sym) (\, arg))) (t (eval (\, sym))))) nil [57790 57990]) ("mc--common-completion" function nil ("alist") nil (\` (try-completion "" (\, alist))) nil [57992 58151]) ("mc--byte-recompile-files" function nil ("files") nil (let ((tmp-fl files)) (while (car-safe tmp-fl) (let* ((el-file (car tmp-fl)) (elc-file (concat el-file emacs-lisp-bytecomp-ext))) (mc--msg "Checking file %s ..." el-file) (if (and (file-newer-than-file-p el-file elc-file) (or (not emacs-lisp-byte-compile-dir-interactive-p) (y-or-n-p (format "byte-recompile file %s? " el-file)))) (condition-case err (byte-compile-file el-file) (error (mc--msg "Failing to byte-compile %s, #error %s" el-file err)))) (setq tmp-fl (cdr-safe tmp-fl)))) (mc--msg "All files processed")) nil [58153 59052]) ("mc--which" function nil ("file") nil (if (not (stringp file)) (error "mc--which: nil FILE arg")) nil [59054 60101]) ("mc--find-compiler" function nil nil nil (mc--msg "Searching for your favourite %s compiler ..." mode-name) nil [60103 60625]) ("mc--find-to-compile-file" function nil ("&optional" "fname") nil (let ((file-name (or fname (buffer-file-name) (error "Compilation abort: Buffer %s has no filename." (buffer-name)))) (assoc-file nil) (found nil) (pos 0)) (cond ((string-match mc--source-ext-regexp file-name) (file-name-nondirectory file-name)) ((setq pos (string-match mc--compfile-regexp file-name)) (let ((tmp-ext-lst mc--source-ext-lst)) (mc--msg "Looking for a compileable companion file for %s..." (file-name-nondirectory file-name)) (while (and tmp-ext-lst (not (setq found (file-readable-p (setq assoc-file (concat (substring file-name 0 pos) "." (car tmp-ext-lst))))))) (setq tmp-ext-lst (cdr tmp-ext-lst)))) (if found (file-name-nondirectory assoc-file) (mc--msg "Couldn't find any compileable companion file for %s ..." (file-name-nondirectory file-name)) nil)) (t (error "Compilation abort: Don't know how to compile %s." (file-name-nondirectory file-name))))) nil [60627 62368]) ("mc--guess-compile-result-fname" function nil ("infile") nil (let ((base-fname (substring infile 0 (string-match mc--source-ext-regexp infile)))) (save-excursion (set-buffer (find-file-noselect infile)) (save-excursion (save-restriction (widen) (goto-char (point-min)) (if (re-search-forward mc--find-C-main-regexp (point-max) t) (concat base-fname mode-compile-exe-file-ext) (concat base-fname "." mc--outfile-ext)))))) nil [62370 63288]) ("mc--build-output-args" function nil ("infile") nil (mc--msg "Looking into %s to build compile command ..." infile) nil [63290 63813]) ("mc--set-remote-cmd" function nil ("remote-host" "&optional" "username" "pathname") nil (if (stringp remote-host) (let ((host-infos (assoc remote-host mode-compile-remote-hosts-alist))) (setq mc--remote-host remote-host) (setq mc--remote-username (or username (let ((usrnam (cdr host-infos))) (if usrnam (cond ((stringp usrnam) usrnam) ((functionp usrnam) (funcall usrnam mc--remote-host)) (t (mc--msg "%s is not a valid option using user-login-name" (pp-to-string usrnam)) (user-login-name))) (user-login-name))))) (setq mc--remote-pathname pathname) (or host-infos (setq mode-compile-remote-hosts-alist (append (list (list remote-host)) mode-compile-remote-hosts-alist))) (setq mc--remote-command (concat mode-compile-remote-execute-command " " mode-compile-remote-execute-set-host-arg " " mc--remote-host " " mode-compile-remote-execute-set-username-arg " " mc--remote-username " " mode-compile-remote-execute-misc-args " " mode-compile-remote-execute-set-command-arg " "))) (let ((rhost (completing-read "Remote host to compile to: " mode-compile-remote-hosts-alist nil nil (or mc--remote-host (car-safe (car-safe mode-compile-remote-hosts-alist))) mc--remote-host-history))) (or (string= rhost "") (mc--set-remote-cmd rhost)))) nil [63815 66254]) ("mc--makefile-test-p" function nil ("makefile") nil (cond ((or (not makefile) (string-equal makefile "")) (mc--msg "Empty makefile selection") nil) ((file-directory-p makefile) (mc--msg "Makefile selection %s is a directory !!" makefile) nil) ((not (file-readable-p makefile)) (mc--msg "Makefile %s unreadable" makefile) nil) (t)) nil [66474 66837]) ("if" code nil [66840 67097]) ("mc--get-makefile-rules" function nil ("makefile") nil (if (or (not mc--mkfl-buffer-tick) (not (equal mc--mkfl-buffer-tick (buffer-modified-tick)))) (save-excursion (save-restriction (widen) (goto-char (point-min)) (setq mc--mkfl-buffer-tick (buffer-modified-tick)) (setq mc--makefile-rules nil) (mc--msg "Extracting rules from %s ..." makefile) (while (re-search-forward mc--makefile-rules-regexp nil t) (let ((rule (buffer-substring (match-beginning 1) (match-end 1)))) (if (and (or (not mode-compile-ignore-makerule-regexp) (not (string-match mode-compile-ignore-makerule-regexp rule))) (not (mc--member rule mc--makefile-rules))) (setq mc--makefile-rules (append mc--makefile-rules (list rule)))))))) (mc--msg "Rules had already been extracted from %s ..." makefile)) nil [67099 68603]) ("mc--makerule-completion" function nil ("alist" "outfile" "&optional" "pref") nil (let ((preference (or pref mode-compile-prefered-default-makerule))) (mc--msg "Prefered makerule choice is '%s" preference) (cond ((eq preference (quote none)) (or (mc--common-completion alist) "")) ((eq preference (quote all)) (if (assoc "all" alist) "all" (mc--makerule-completion alist outfile (quote none)))) ((eq preference (quote file)) (or outfile (mc--makerule-completion alist outfile (quote none)))) ((eq preference (quote default)) (if (assoc "default" alist) "default" "")) (t (mc--msg "Invalid `mode-compile-prefered-default-makerule': '%s" mode-compile-prefered-default-makerule) (mc--makerule-completion alist outfile (quote none))))) nil [68605 69687]) ("mc--choose-makefile-rule" function nil ("makefile" "&optional" "outfile") nil (save-excursion (set-buffer (find-file-noselect makefile)) (setq mc--selected-makerule (let* ((mk-rules-alist (mc--get-makefile-rules makefile)) (choices (mapcar (quote (lambda (x) (list x))) (if (or (not outfile) (mc--member outfile mk-rules-alist)) mk-rules-alist (append mk-rules-alist (list outfile)))))) (completing-read (if mode-compile-expert-p "Make rule: " "Using `make', enter rule to rebuild ([TAB] to complete): ") choices nil nil (or mc--selected-makerule (mc--makerule-completion choices outfile (if outfile (quote file)))) mc--selected-makerule-history)))) nil [69689 71048]) ("mc--cleanup-makefile-list" function nil ("makefile-list") nil (\` (let ((newlist)) (mapcar (quote (lambda (x) (if (and (mc--makefile-test-p x) (or (not mode-compile-ignore-makefile-backups) (not (string-match mode-compile-makefile-backups-regexp x)))) (setq newlist (cons x newlist)) (mc--msg "Removing makefile \"%s\" from completion list" x)))) (\, makefile-list)) newlist)) nil [71050 71661]) ("mc--makefile-to-use" function nil ("&optional" "directory") nil (let ((makefile-list (mc--cleanup-makefile-list (directory-files (or directory default-directory) nil mode-compile-makefile-regexp t)))) (cond ((not makefile-list) nil) ((and (not (cdr-safe makefile-list)) (mc--makefile-test-p (car makefile-list))) (car makefile-list)) (t (let ((choices (mapcar (quote (lambda (x) (list x))) makefile-list)) (makefile nil)) (while (not (mc--makefile-test-p (setq makefile (completing-read (if mode-compile-expert-p "Makefile: " "Using `make', select makefile to use ([TAB] to complete): ") choices nil t (or mc--selected-makefile (mc--common-completion choices)) mc--selected-makefile-history))))) makefile)))) nil [71663 73325]) ("mc--set-command" function nil ("&optional" "file") nil (setq completion-ignore-case nil) nil [73327 75494]) ("mc--shell-compile" function nil ("shell" "dbgflags" "&optional" "errors-regexp-alist") nil (let* ((shcmd (or (mc--which shell) (error "Compilation abort: command %s not found" shell))) (shfile (or mc--remote-pathname (buffer-file-name) (error "Compilation abort: Buffer %s has no filename" (buffer-name)))) (run-cmd (concat shcmd " " dbgflags " " shfile " " (setq mc--shell-args (read-string (if mode-compile-expert-p "Argv: " (format "Arguments to %s %s script: " shfile shell)) mc--shell-args))))) (if errors-regexp-alist (progn (or (listp errors-regexp-alist) (error "Compilation abort: In mc--shell-compile errors-regexp-alist not a list.")) (mapcar (quote (lambda (x) (if (mc--member x compilation-error-regexp-alist) nil (setq compilation-error-regexp-alist (append (list x) compilation-error-regexp-alist))))) errors-regexp-alist))) (mc--compile run-cmd)) nil [75496 77135]) ("mc--assq-get-fcomp" function nil ("asq") nil (\` (let* ((mode (cdr (\, asq))) (massq (assq mode mode-compile-modes-alist))) (if massq (car-safe (cdr massq))))) nil [77137 77355]) ("mc--assq-get-fkill" function nil ("asq") nil (\` (let* ((mode (cdr (\, asq))) (massq (assq mode mode-compile-modes-alist))) (if massq (car-safe (cdr-safe (cdr massq)))))) nil [77357 77591]) ("mc--lookin-for-shell" function nil nil nil (mc--msg "Looking if buffer %s is a shell script..." (buffer-name)) nil [77593 78424]) ("mc--lookat-name" function nil nil nil (mc--msg "Trying to guess compile command from buffer %s file name..." (buffer-name)) nil [78426 79319]) ("cc-compile" function nil nil nil "Run `compile' with a dynamically built command for `c-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run a C compiler on the file or it's companion.

See also variables:
 -- cc-compilers-list
 -- cc-default-compiler
 -- cc-companion-file-regexp
 -- cc-compiler-varenv
 -- cc-cflags-varenv
 -- cc-source-ext-list
 -- cc-headers-ext-list
 -- cc-source-file-ext-regexp" nil [79357 80475]) ("java-compile" function nil nil nil "Run `compile' with a dynamically built command for `java-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run a Java compiler on the file or it's
companion.

See also variables:
 -- java-compilers-list
 -- java-default-compiler
 -- java-companion-file-regexp
 -- java-compiler-varenv
 -- java-cflags-varenv
 -- java-source-ext-list
 -- java-headers-ext-list
 -- java-source-file-ext-regexp" nil [80477 81641]) ("c++-compile" function nil nil nil "Run `compile' with a dynamically built command for `c++-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run a C++ compiler on the file or it's companion.

See also variables:
 -- c++-compilers-list
 -- c++-default-compiler
 -- c++-companion-file-regexp
 -- c++-compiler-varenv
 -- c++-cflags-varenv
 -- c++-source-ext-list
 -- c++-headers-ext-list
 -- c++-source-file-ext-regexp" nil [81643 82785]) ("ada-compile" function nil nil nil "Run `compile' with a dynamically built command for `ada-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run an Ada compiler on the file.

See also variables:
 -- ada-compilers-list
 -- ada-default-compiler
 -- ada-companion-file-regexp
 -- ada-compiler-varenv
 -- ada-aflags-varenv
 -- ada-source-ext-list
 -- ada-headers-ext-list
 -- ada-source-file-ext-regexp)" nil [82788 83914]) ("f77-compile" function nil nil nil "Run `compile' with a dynamically built command for `fortran-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run a Fortran compiler on the file or it's companion..

See also variables:
 -- f77-compilers-list
 -- f77-default-compiler
 -- f77-companion-file-regexp
 -- f77-compiler-varenv
 -- f77-cflags-varenv
 -- f77-source-ext-list
 -- f77-headers-ext-list
 -- f77-source-file-ext-regexp)" nil [83917 85069]) ("elisp-compile" function nil nil nil "Run `byte-compile' on the current Emacs lisp buffer.
For `emacs-lisp-mode' and `lisp-interaction-mode'.

Produce a `.elc' file if possible or `byte-compile' only the buffer." nil [85072 85609]) ("makefile-compile" function nil ("&optional" "makefile") nil "Run `make' on the current-buffer (`makefile-mode').

The user is prompted for a selection of make rules to build." nil [85612 86268]) ("dired-compile" function nil nil nil "Run `make' if a Makefile is present in current directory (`dired-mode').

The user is prompted for a selection of a makefile to choose if many
matching `mode-compile-makefile-regexp' are present in the directory and
for the make rules to build. If directory contain no makefile the function
try to find if there are some un-byte-compiled .el files and recompile them
if needed.
Ask for the complete `compile-command' if no makefile and no .el files found." nil [86271 87406]) ("sh-compile" function nil nil nil "Run `sh-command' (Bourne Shell) with `sh-dbg-flags' on current-buffer (`sh-mode').

User is prompted for arguments to run his sh program with.
If you want to step throught errors set the variable `sh-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or sh-compilation-error-regexp-alist." nil [87409 87882]) ("csh-compile" function nil nil nil "Run `csh-command' (C Shell) with `csh-dbg-flags' on current-buffer (`csh-mode').

User is prompted for arguments to run his csh program with.
If you want to step throught errors set the variable `csh-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or csh-compilation-error-regexp-alist." nil [87885 88363]) ("zsh-compile" function nil nil nil "Run `zsh-command' (Z Shell) with `zsh-dbg-flags' on current-buffer (`zsh-mode').

User is prompted for arguments to run his zsh program with.
If you want to step throught errors set the variable `zsh-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or zsh-compilation-error-regexp-alist." nil [88366 88844]) ("perl-compile" function nil nil nil "Run Perl with `perl-dbg-flags' on current-buffer (`perl-mode').

User is prompted for arguments to run his perl program with.
If you want to step throught errors set the variable `perl-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or perl-compilation-error-regexp-alist." nil [88847 89315]) ("tcl-compile" function nil nil nil "Run `tcl-command' with `tcl-dbg-flags' on current-buffer (`tcl-mode').

User is prompted for arguments to run his Tcl/Tk program with.
If you want to step throught errors set the variable `tcl-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or tcl-compilation-error-regexp-alist." nil [89318 89798]) ("python-compile" function nil nil nil "Run `python-command' with `python-dbg-flags' on current-buffer (`python-mode').

User is prompted for arguments to run his Python program with.
If you want to step throught errors set the variable `python-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or python-compilation-error-regexp-alist." nil [89801 90307]) ("ruby-compile" function nil nil nil "Run `ruby-command' with `ruby-dbg-flags' on current-buffer (`ruby-mode').

User is prompted for arguments to run their ruby program with.
If you want to step throught errors set the variable `ruby-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or ruby-compilation-error-regexp-alist." nil [90309 90799]) ("default-compile" function nil nil nil "Default function invoked by `mode-compile' (\\[mode-compile])
when everything else failed.

Ask to user to edit `compile-command' and run `compile' (\\[compile]) with it." nil [90801 91278]) ("mc--makefile" variable nil nil nil nil nil [91280 91301]) ("guess-compile" function nil nil nil "Try to guess how to compile current-buffer.

When the compile command could not be extrapolated from major-mode this function
is called which try to guess from number of parameters which command to build.
The steps to guess which command to use to compile are:
  1st : Look into the file to check if it is a shell script
        See variable mode-compile-shell-alist
  2nd : Try to guess from the file name
        See variable mode-compile-filename-regexp-alist
  3rd : Look for a makefile in the current directory
        See variable mode-compile-makefile-regexp
  Last: Give up and ask user for the command to use
        See function default-compile" nil [91336 92914]) ("and" code nil [93016 93095]) ("mode-compile-submit-bug-report" function nil nil ((user-visible . t)) "*Submit via mail a bug report on mode-compile v2.27." nil [93112 94398]) ("mode-compile" function nil ("&optional" "remote-host") ((user-visible . t)) "*Compile the file in the current buffer with a dynamically built command.

The command is built according to the current major mode the function
was invoked from.

Running this command preceded by universal-argument (\\[universal-argument])
allows remote compilation, the user is prompted for a host name to run the
compilation command on.

Currently know how to compile in:
 `c-mode' ,              -- function cc-compile.
 `java-mode' ,           -- function java-compile.
 `c++-mode',             -- function c++-compile.
 `ada-mode',             -- function ada-compile.
 `fortran-mode',         -- function f77-compile.
 `emacs-lisp-mode'       -- function elisp-compile.
 `lisp-interaction-mode' -- function elisp-compile.
 `makefile-mode'         -- function makefile-compile.
 `dired-mode'            -- function dired-compile.
 `sh-mode'               -- function sh-compile.
 `csh-mode'              -- function csh-compile.
 `zsh-mode'              -- function zsh-compile.
 `perl-mode'             -- function perl-compile.
 `cperl-mode'            -- function perl-compile.
 `tcl-mode'              -- function tcl-compile.
 `python-mode'           -- function python-compile.
 `ruby-mode'             -- function ruby-compile.
 `fundamental-mode'      -- function guess-compile.
 `text-mode'             -- function guess-compile.
 `indented-text-mode'    -- function guess-compile.
 `compilation-mode'      -- function default-compile.
 The function `guess-compile' is called when mode is unknown.

The variable `mode-compile-modes-alist' contain description of known
modes.  The hooks variables `mode-compile-before-compile-hook' and
`mode-compile-after-compile-hook' are run just before and after
invoking the compile command of the mode.

Use the command `mode-compile-kill' (\\[mode-compile-kill]) to abort a
running compilation.

Bound on \\[mode-compile]." nil [94417 98756]) ("mode-compile" package nil nil nil [98758 98781]) ("mode-compile-kill" function nil nil ((user-visible . t)) "*Kill the running compilation launched by `mode-compile' (\\[mode-compile]) command.

The compilation command is killed according to the current major mode
the function was invoked from.

Currently know how to kill compilations from:
 `c-mode' ,              -- function kill-compilation.
 `java-mode' ,           -- function kill-compilation.
 `c++-mode' ,            -- function kill-compilation.
 `ada-mode' ,            -- function kill-compilation.
 `fortran-mode' ,        -- function kill-compilation.
 `emacs-lisp-mode'       -- function keyboard-quit.
 `lisp-interaction-mode' -- function keyboard-quit.
 `makefile-mode'         -- function kill-compilation.
 `dired-mode'            -- function kill-compilation.
 `sh-mode'               -- function kill-compilation.
 `csh-mode'              -- function kill-compilation.
 `zsh-mode'              -- function kill-compilation.
 `perl-mode'             -- function kill-compilation.
 `cperl-mode'            -- function kill-compilation.
 `tcl-mode'              -- function kill-compilation.
 `python-mode'           -- function kill-compilation.
 `ruby-mode'             -- function kill-compilation.
 `fundamental-mode'      -- Bound dynamically.
 `text-mode'             -- Bound dynamically.
 `indented-text-mode'    -- Bound dynamically.
 `compilation-mode'      -- function kill-compilation.

The variable `mode-compile-modes-alist' contain description of ALL
known modes.  The hooks variables `mode-compile-before-kill-hook' and
`mode-compile-after-kill-hook' are run just before and after invoking
the kill compile command of the mode.

Bound on \\[mode-compile-kill]." nil [98800 101320]) ("mode-compile-kill" package nil nil nil [101322 101350]))
    )
   )
  )
